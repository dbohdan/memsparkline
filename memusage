#! /usr/bin/env tclsh

package require Tcl 8.6


namespace eval sparklines {
    variable ticks [list ▁ ▂ ▃ ▄ ▅ ▆ ▇ █]
    variable tickMax [expr {[llength $ticks] - 1}]
}


proc sparklines::render {min max data} {
    variable ticks
    variable tickMax

    if {$min == $max} {
        # All data points are the same.
        return [string repeat \
            [lindex $ticks [expr {int($tickMax / 2)}]] \
            [llength $data] \
        ]
    } else {
        return [join [lmap x $data {
            set normalized [expr {
                int($tickMax * ($x - $min) / ($max - $min))
            }]
            lindex $ticks $normalized
        }] {}]
    }
}


namespace eval memusage {
    variable sparklineLength 20
}


proc memusage::running? pid {
    try {
        exec kill -0 $pid
    } on error _ {
        return 0
    }

    return 1
}


proc memusage::vmrss pid {
    try {
        set ch [open /proc/$pid/status]
        while {[gets $ch line] >= 0} {
            if {[regexp ^VmRSS: $line]} {
                return [lindex $line 1]
            }
        }

        error [list can't find line with VmRSS for $pid]
    } finally {
        close $ch
    }
}


# A hack.
proc memusage::descendents pid {
    set tree [exec pstree -p $pid]
    return [lmap {_ pid} [regexp -all -inline {[^\}]\((\d+)\)} $tree] {
        lindex $pid
    }]
}


proc memusage::track parent {
    variable sparklineLength

    set history {}
    set max 0

    while {[running? $parent]} {
        set pids [descendents $parent]

        set total 0
        foreach pid $pids {
            try {
                set vmrss [vmrss $pid]
                incr total $vmrss
            } on error _ {}
        }
        lappend history $total

        after 1000

        if {$total > $max} { set max $total }

        set latest [lrange $history end-$sparklineLength end]
        set sparkline [sparklines::render 0 $max $latest]
        puts -nonewline stderr "\r$sparkline $total"
    }


    return [list $max $history]
}


proc memusage::main argv {
    set pid [exec {*}$argv >@ stdout 2>@ stderr &]
    lassign [track $pid] max history

    if {[llength $history] == 0} {
        puts stderr [list no data collected]
        return
    }

    puts stderr {}
    puts stderr [list max: $max]
    puts stderr [list avg: [expr {
        [::tcl::mathop::+ {*}$history] / [llength $history]
    }]]
}


# If this is the main script...
if {[info exists argv0] && ([file tail [info script]] eq [file tail $argv0])} {
    memusage::main $argv
}
